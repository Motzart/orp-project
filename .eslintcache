[{"/Users/yuriioleshko/orp-project/src/App.js":"1","/Users/yuriioleshko/orp-project/src/screen/Home.js":"2","/Users/yuriioleshko/orp-project/src/screen/Mint.js":"3","/Users/yuriioleshko/orp-project/src/Layout/Footer.js":"4","/Users/yuriioleshko/orp-project/src/Layout/Header.js":"5","/Users/yuriioleshko/orp-project/src/screen/Map.js":"6","/Users/yuriioleshko/orp-project/src/screen/ProjectDetails.js":"7","/Users/yuriioleshko/orp-project/src/index.js":"8","/Users/yuriioleshko/orp-project/src/screen/OperatingArea.js":"9","/Users/yuriioleshko/orp-project/src/screen/Bond.js":"10","/Users/yuriioleshko/orp-project/src/screen/AccountSetup.js":"11","/Users/yuriioleshko/orp-project/src/container/PJContainer/PJContainer.js":"12","/Users/yuriioleshko/orp-project/src/screen/GenInfo.js":"13","/Users/yuriioleshko/orp-project/src/screen/PLocation.js":"14","/Users/yuriioleshko/orp-project/src/screen/ReforeData.js":"15","/Users/yuriioleshko/orp-project/src/reportWebVitals.js":"16","/Users/yuriioleshko/orp-project/src/container/PJContainer/index.js":"17","/Users/yuriioleshko/orp-project/src/screen/Disclaimer.js":"18","/Users/yuriioleshko/orp-project/src/screen/NewProject.js":"19","/Users/yuriioleshko/orp-project/src/utills/openlocal.js":"20","/Users/yuriioleshko/orp-project/src/screen/MapBox.js":"21","/Users/yuriioleshko/orp-project/src/screen/PITable.js":"22"},{"size":1332,"mtime":1612444150429,"results":"23","hashOfConfig":"24"},{"size":1298,"mtime":1611818621477,"results":"25","hashOfConfig":"24"},{"size":379,"mtime":1611818621477,"results":"26","hashOfConfig":"24"},{"size":199,"mtime":1611818621475,"results":"27","hashOfConfig":"24"},{"size":438,"mtime":1612426142589,"results":"28","hashOfConfig":"24"},{"size":3010,"mtime":1612426142592,"results":"29","hashOfConfig":"24"},{"size":5399,"mtime":1611852844040,"results":"30","hashOfConfig":"24"},{"size":569,"mtime":1611818621476,"results":"31","hashOfConfig":"24"},{"size":1128,"mtime":1611853272919,"results":"32","hashOfConfig":"24"},{"size":2473,"mtime":1611818621477,"results":"33","hashOfConfig":"24"},{"size":1253,"mtime":1612426142591,"results":"34","hashOfConfig":"24"},{"size":1896,"mtime":1611860832106,"results":"35","hashOfConfig":"24"},{"size":3462,"mtime":1611858161815,"results":"36","hashOfConfig":"24"},{"size":1772,"mtime":1612444171132,"results":"37","hashOfConfig":"24"},{"size":1625,"mtime":1612426142594,"results":"38","hashOfConfig":"24"},{"size":362,"mtime":1611818621476,"results":"39","hashOfConfig":"24"},{"size":42,"mtime":1611837133390,"results":"40","hashOfConfig":"24"},{"size":755,"mtime":1611818621477,"results":"41","hashOfConfig":"24"},{"size":88,"mtime":1611818621478,"results":"42","hashOfConfig":"24"},{"size":26461,"mtime":1612384367231,"results":"43","hashOfConfig":"24"},{"size":4773,"mtime":1612446146863,"results":"44","hashOfConfig":"24"},{"size":3110,"mtime":1612426142592,"results":"45","hashOfConfig":"24"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},"t3hyo3",{"filePath":"49","messages":"50","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"51","messages":"52","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"53","messages":"54","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"55","messages":"56","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"59","messages":"60","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"61","messages":"62","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"63"},{"filePath":"64","messages":"65","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"66","messages":"67","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"68"},{"filePath":"69","messages":"70","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"71"},{"filePath":"72","messages":"73","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"74","messages":"75","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"76","messages":"77","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"78","messages":"79","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"80"},{"filePath":"81","messages":"82","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"83","messages":"84","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"85","messages":"86","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"87","messages":"88","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"89","messages":"90","errorCount":0,"warningCount":16,"fixableErrorCount":0,"fixableWarningCount":0,"source":"91","usedDeprecatedRules":"48"},{"filePath":"92","messages":"93","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"94","messages":"95","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/yuriioleshko/orp-project/src/App.js",[],["96","97"],"/Users/yuriioleshko/orp-project/src/screen/Home.js",[],"/Users/yuriioleshko/orp-project/src/screen/Mint.js",[],"/Users/yuriioleshko/orp-project/src/Layout/Footer.js",[],"/Users/yuriioleshko/orp-project/src/Layout/Header.js",[],"/Users/yuriioleshko/orp-project/src/screen/Map.js",[],"/Users/yuriioleshko/orp-project/src/screen/ProjectDetails.js",[],"/Users/yuriioleshko/orp-project/src/index.js",[],["98","99"],"/Users/yuriioleshko/orp-project/src/screen/OperatingArea.js",[],"/Users/yuriioleshko/orp-project/src/screen/Bond.js",[],["100","101"],"/Users/yuriioleshko/orp-project/src/screen/AccountSetup.js",[],["102","103"],"/Users/yuriioleshko/orp-project/src/container/PJContainer/PJContainer.js",[],"/Users/yuriioleshko/orp-project/src/screen/GenInfo.js",[],"/Users/yuriioleshko/orp-project/src/screen/PLocation.js",["104","105"],"/Users/yuriioleshko/orp-project/src/screen/ReforeData.js",[],["106","107"],"/Users/yuriioleshko/orp-project/src/reportWebVitals.js",[],"/Users/yuriioleshko/orp-project/src/container/PJContainer/index.js",[],"/Users/yuriioleshko/orp-project/src/screen/Disclaimer.js",[],"/Users/yuriioleshko/orp-project/src/screen/NewProject.js",[],"/Users/yuriioleshko/orp-project/src/utills/openlocal.js",["108","109","110","111","112","113","114","115","116","117","118","119","120","121","122","123"],"\n(function(root, factory) {\n    /* global define, module */\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define([], function(b) {\n            return (root.returnExportsGlobal = factory(b));\n        });\n    } else if (typeof module === 'object' && module.exports) {\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like environments that support module.exports,\n        // like Node.\n        module.exports = factory();\n    } else {\n        // Browser globals\n        root.OpenLocationCode = factory();\n    }\n}(this, function() {\n    var OpenLocationCode = {};\n\n    /**\n     * Provides a normal precision code, approximately 14x14 meters.\n     * @const {number}\n     */\n    OpenLocationCode.CODE_PRECISION_NORMAL = 10;\n\n    /**\n     * Provides an extra precision code, approximately 2x3 meters.\n     * @const {number}\n     */\n    OpenLocationCode.CODE_PRECISION_EXTRA = 11;\n\n    // A separator used to break the code into two parts to aid memorability.\n    var SEPARATOR_ = '+';\n\n    // The number of characters to place before the separator.\n    var SEPARATOR_POSITION_ = 8;\n\n    // The character used to pad codes.\n    var PADDING_CHARACTER_ = '0';\n\n    // The character set used to encode the values.\n    var CODE_ALPHABET_ = '23456789CFGHJMPQRVWX';\n\n    // The base to use to convert numbers to/from.\n    var ENCODING_BASE_ = CODE_ALPHABET_.length;\n\n    // The maximum value for latitude in degrees.\n    var LATITUDE_MAX_ = 90;\n\n    // The maximum value for longitude in degrees.\n    var LONGITUDE_MAX_ = 180;\n\n    // The max number of digits to process in a plus code.\n    var MAX_DIGIT_COUNT_ = 15;\n\n    // Maximum code length using lat/lng pair encoding. The area of such a\n    // code is approximately 13x13 meters (at the equator), and should be suitable\n    // for identifying buildings. This excludes prefix and separator characters.\n    var PAIR_CODE_LENGTH_ = 10;\n\n    // First place value of the pairs (if the last pair value is 1).\n    var PAIR_FIRST_PLACE_VALUE_ = Math.pow(\n        ENCODING_BASE_, (PAIR_CODE_LENGTH_ / 2 - 1));\n\n    // Inverse of the precision of the pair section of the code.\n    var PAIR_PRECISION_ = Math.pow(ENCODING_BASE_, 3);\n\n    // The resolution values in degrees for each position in the lat/lng pair\n    // encoding. These give the place value of each position, and therefore the\n    // dimensions of the resulting area.\n    var PAIR_RESOLUTIONS_ = [20.0, 1.0, .05, .0025, .000125];\n\n    // Number of digits in the grid precision part of the code.\n    var GRID_CODE_LENGTH_ = MAX_DIGIT_COUNT_ - PAIR_CODE_LENGTH_;\n\n    // Number of columns in the grid refinement method.\n    var GRID_COLUMNS_ = 4;\n\n    // Number of rows in the grid refinement method.\n    var GRID_ROWS_ = 5;\n\n    // First place value of the latitude grid (if the last place is 1).\n    var GRID_LAT_FIRST_PLACE_VALUE_ = Math.pow(\n        GRID_ROWS_, (GRID_CODE_LENGTH_ - 1));\n\n    // First place value of the longitude grid (if the last place is 1).\n    var GRID_LNG_FIRST_PLACE_VALUE_ = Math.pow(\n        GRID_COLUMNS_, (GRID_CODE_LENGTH_ - 1));\n\n    // Multiply latitude by this much to make it a multiple of the finest\n    // precision.\n    var FINAL_LAT_PRECISION_ = PAIR_PRECISION_ *\n        Math.pow(GRID_ROWS_, (MAX_DIGIT_COUNT_ - PAIR_CODE_LENGTH_));\n\n    // Multiply longitude by this much to make it a multiple of the finest\n    // precision.\n    var FINAL_LNG_PRECISION_ = PAIR_PRECISION_ *\n        Math.pow(GRID_COLUMNS_, (MAX_DIGIT_COUNT_ - PAIR_CODE_LENGTH_));\n\n    // Minimum length of a code that can be shortened.\n    var MIN_TRIMMABLE_CODE_LEN_ = 6;\n\n    /**\n     @return {string} Returns the OLC alphabet.\n     */\n    OpenLocationCode.getAlphabet = function() {\n        return CODE_ALPHABET_;\n    };\n\n    /**\n     * Determines if a code is valid.\n     *\n     * To be valid, all characters must be from the Open Location Code character\n     * set with at most one separator. The separator can be in any even-numbered\n     * position up to the eighth digit.\n     *\n     * @param {string} code The string to check.\n     * @return {boolean} True if the string is a valid code.\n     */\n    var isValid = OpenLocationCode.isValid = function(code) {\n        if (!code || typeof code !== 'string') {\n            return false;\n        }\n        // The separator is required.\n        if (code.indexOf(SEPARATOR_) == -1) {\n            return false;\n        }\n        if (code.indexOf(SEPARATOR_) != code.lastIndexOf(SEPARATOR_)) {\n            return false;\n        }\n        // Is it the only character?\n        if (code.length == 1) {\n            return false;\n        }\n        // Is it in an illegal position?\n        if (code.indexOf(SEPARATOR_) > SEPARATOR_POSITION_ ||\n            code.indexOf(SEPARATOR_) % 2 == 1) {\n            return false;\n        }\n        // We can have an even number of padding characters before the separator,\n        // but then it must be the final character.\n        if (code.indexOf(PADDING_CHARACTER_) > -1) {\n            // Short codes cannot have padding\n            if (code.indexOf(SEPARATOR_) < SEPARATOR_POSITION_) {\n                return false;\n            }\n            // Not allowed to start with them!\n            if (code.indexOf(PADDING_CHARACTER_) == 0) {\n                return false;\n            }\n            // There can only be one group and it must have even length.\n            var padMatch = code.match(new RegExp('(' + PADDING_CHARACTER_ + '+)', 'g'));\n            if (padMatch.length > 1 || padMatch[0].length % 2 == 1 ||\n                padMatch[0].length > SEPARATOR_POSITION_ - 2) {\n                return false;\n            }\n            // If the code is long enough to end with a separator, make sure it does.\n            if (code.charAt(code.length - 1) != SEPARATOR_) {\n                return false;\n            }\n        }\n        // If there are characters after the separator, make sure there isn't just\n        // one of them (not legal).\n        if (code.length - code.indexOf(SEPARATOR_) - 1 == 1) {\n            return false;\n        }\n\n        // Strip the separator and any padding characters.\n        code = code.replace(new RegExp('\\\\' + SEPARATOR_ + '+'), '')\n            .replace(new RegExp(PADDING_CHARACTER_ + '+'), '');\n        // Check the code contains only valid characters.\n        for (var i = 0, len = code.length; i < len; i++) {\n            var character = code.charAt(i).toUpperCase();\n            if (character != SEPARATOR_ && CODE_ALPHABET_.indexOf(character) == -1) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    /**\n     * Determines if a code is a valid short code.\n     *\n     * @param {string} code The string to check.\n     * @return {boolean} True if the string can be produced by removing four or\n     *     more characters from the start of a valid code.\n     */\n    var isShort = OpenLocationCode.isShort = function(code) {\n        // Check it's valid.\n        if (!isValid(code)) {\n            return false;\n        }\n        // If there are less characters than expected before the SEPARATOR.\n        if (code.indexOf(SEPARATOR_) >= 0 &&\n            code.indexOf(SEPARATOR_) < SEPARATOR_POSITION_) {\n            return true;\n        }\n        return false;\n    };\n\n    /**\n     * Determines if a code is a valid full Open Location Code.\n     *\n     * @param {string} code The string to check.\n     * @return {boolean} True if the code represents a valid latitude and\n     *     longitude combination.\n     */\n    var isFull = OpenLocationCode.isFull = function(code) {\n        if (!isValid(code)) {\n            return false;\n        }\n        // If it's short, it's not full.\n        if (isShort(code)) {\n            return false;\n        }\n\n        // Work out what the first latitude character indicates for latitude.\n        var firstLatValue = CODE_ALPHABET_.indexOf(\n            code.charAt(0).toUpperCase()) * ENCODING_BASE_;\n        if (firstLatValue >= LATITUDE_MAX_ * 2) {\n            // The code would decode to a latitude of >= 90 degrees.\n            return false;\n        }\n        if (code.length > 1) {\n            // Work out what the first longitude character indicates for longitude.\n            var firstLngValue = CODE_ALPHABET_.indexOf(\n                code.charAt(1).toUpperCase()) * ENCODING_BASE_;\n            if (firstLngValue >= LONGITUDE_MAX_ * 2) {\n                // The code would decode to a longitude of >= 180 degrees.\n                return false;\n            }\n        }\n        return true;\n    };\n\n    /**\n     * Encode a location into an Open Location Code.\n     *\n     * @param {number} latitude The latitude in signed decimal degrees. It will\n     *     be clipped to the range -90 to 90.\n     * @param {number} longitude The longitude in signed decimal degrees. Will be\n     *     normalised to the range -180 to 180.\n     * @param {?number} codeLength The length of the code to generate. If\n     *     omitted, the value OpenLocationCode.CODE_PRECISION_NORMAL will be used.\n     *     For a more precise result, OpenLocationCode.CODE_PRECISION_EXTRA is\n     *     recommended.\n     * @return {string} The code.\n     * @throws {Exception} if any of the input values are not numbers.\n     */\n    var encode = OpenLocationCode.encode = function(latitude,\n                                                    longitude, codeLength) {\n        latitude = Number(latitude);\n        longitude = Number(longitude);\n        if (typeof codeLength == 'undefined') {\n            codeLength = OpenLocationCode.CODE_PRECISION_NORMAL;\n        } else {\n            codeLength = Math.min(MAX_DIGIT_COUNT_, Number(codeLength));\n        }\n        if (isNaN(latitude) || isNaN(longitude) || isNaN(codeLength)) {\n            throw new Error('ValueError: Parameters are not numbers');\n        }\n        if (codeLength < 2 ||\n            (codeLength < PAIR_CODE_LENGTH_ && codeLength % 2 == 1)) {\n            throw new Error('IllegalArgumentException: Invalid Open Location Code length');\n        }\n        // Ensure that latitude and longitude are valid.\n        latitude = clipLatitude(latitude);\n        longitude = normalizeLongitude(longitude);\n        // Latitude 90 needs to be adjusted to be just less, so the returned code\n        // can also be decoded.\n        if (latitude == 90) {\n            latitude = latitude - computeLatitudePrecision(codeLength);\n        }\n        var code = '';\n\n        // Compute the code.\n        // This approach converts each value to an integer after multiplying it by\n        // the final precision. This allows us to use only integer operations, so\n        // avoiding any accumulation of floating point representation errors.\n\n        // Multiply values by their precision and convert to positive.\n        // Force to integers so the division operations will have integer results.\n        // Note: JavaScript requires rounding before truncating to ensure precision!\n        var latVal =\n            Math.floor(Math.round((latitude + LATITUDE_MAX_) * FINAL_LAT_PRECISION_ * 1e6) / 1e6);\n        var lngVal =\n            Math.floor(Math.round((longitude + LONGITUDE_MAX_) * FINAL_LNG_PRECISION_ * 1e6) / 1e6);\n\n        // Compute the grid part of the code if necessary.\n        if (codeLength > PAIR_CODE_LENGTH_) {\n            for (var i = 0; i < MAX_DIGIT_COUNT_ - PAIR_CODE_LENGTH_; i++) {\n                var latDigit = latVal % GRID_ROWS_;\n                var lngDigit = lngVal % GRID_COLUMNS_;\n                var ndx = latDigit * GRID_COLUMNS_ + lngDigit;\n                code = CODE_ALPHABET_.charAt(ndx) + code;\n                // Note! Integer division.\n                latVal = Math.floor(latVal / GRID_ROWS_);\n                lngVal = Math.floor(lngVal / GRID_COLUMNS_);\n            }\n        } else {\n            latVal = Math.floor(latVal / Math.pow(GRID_ROWS_, GRID_CODE_LENGTH_));\n            lngVal = Math.floor(lngVal / Math.pow(GRID_COLUMNS_, GRID_CODE_LENGTH_));\n        }\n        // Compute the pair section of the code.\n        for (var i = 0; i < PAIR_CODE_LENGTH_ / 2; i++) {\n            code = CODE_ALPHABET_.charAt(lngVal % ENCODING_BASE_) + code;\n            code = CODE_ALPHABET_.charAt(latVal % ENCODING_BASE_) + code;\n            latVal = Math.floor(latVal / ENCODING_BASE_);\n            lngVal = Math.floor(lngVal / ENCODING_BASE_);\n        }\n\n        // Add the separator character.\n        code = code.substring(0, SEPARATOR_POSITION_) +\n            SEPARATOR_ +\n            code.substring(SEPARATOR_POSITION_);\n\n\n        // If we don't need to pad the code, return the requested section.\n        if (codeLength >= SEPARATOR_POSITION_) {\n            return code.substring(0, codeLength + 1);\n        }\n        // Pad and return the code.\n        return code.substring(0, codeLength) +\n            Array(SEPARATOR_POSITION_ - codeLength + 1).join(PADDING_CHARACTER_) + SEPARATOR_;\n    };\n\n    /**\n     * Decodes an Open Location Code into its location coordinates.\n     *\n     * Returns a CodeArea object that includes the coordinates of the bounding\n     * box - the lower left, center and upper right.\n     *\n     * @param {string} code The code to decode.\n     * @return {OpenLocationCode.CodeArea} An object with the coordinates of the\n     *     area of the code.\n     * @throws {Exception} If the code is not valid.\n     */\n    var decode = OpenLocationCode.decode = function(code) {\n        // This calculates the values for the pair and grid section separately, using\n        // integer arithmetic. Only at the final step are they converted to floating\n        // point and combined.\n        if (!isFull(code)) {\n            throw new Error('IllegalArgumentException: ' +\n                'Passed Open Location Code is not a valid full code: ' + code);\n        }\n        // Strip the '+' and '0' characters from the code and convert to upper case.\n        code = code.replace('+', '').replace(/0/g, '').toLocaleUpperCase('en-US');\n\n        // Initialise the values for each section. We work them out as integers and\n        // convert them to floats at the end.\n        var normalLat = -LATITUDE_MAX_ * PAIR_PRECISION_;\n        var normalLng = -LONGITUDE_MAX_ * PAIR_PRECISION_;\n        var gridLat = 0;\n        var gridLng = 0;\n        // How many digits do we have to process?\n        var digits = Math.min(code.length, PAIR_CODE_LENGTH_);\n        // Define the place value for the most significant pair.\n        var pv = PAIR_FIRST_PLACE_VALUE_;\n        // Decode the paired digits.\n        for (var i = 0; i < digits; i += 2) {\n            normalLat += CODE_ALPHABET_.indexOf(code.charAt(i)) * pv;\n            normalLng += CODE_ALPHABET_.indexOf(code.charAt(i + 1)) * pv;\n            if (i < digits - 2) {\n                pv /= ENCODING_BASE_;\n            }\n        }\n        // Convert the place value to a float in degrees.\n        var latPrecision = pv / PAIR_PRECISION_;\n        var lngPrecision = pv / PAIR_PRECISION_;\n        // Process any extra precision digits.\n        if (code.length > PAIR_CODE_LENGTH_) {\n            // Initialise the place values for the grid.\n            var rowpv = GRID_LAT_FIRST_PLACE_VALUE_;\n            var colpv = GRID_LNG_FIRST_PLACE_VALUE_;\n            // How many digits do we have to process?\n            digits = Math.min(code.length, MAX_DIGIT_COUNT_);\n            for (var i = PAIR_CODE_LENGTH_; i < digits; i++) {\n                var digitVal = CODE_ALPHABET_.indexOf(code.charAt(i));\n                var row = Math.floor(digitVal / GRID_COLUMNS_);\n                var col = digitVal % GRID_COLUMNS_;\n                gridLat += row * rowpv;\n                gridLng += col * colpv;\n                if (i < digits - 1) {\n                    rowpv /= GRID_ROWS_;\n                    colpv /= GRID_COLUMNS_;\n                }\n            }\n            // Adjust the precisions from the integer values to degrees.\n            latPrecision = rowpv / FINAL_LAT_PRECISION_;\n            lngPrecision = colpv / FINAL_LNG_PRECISION_;\n        }\n        // Merge the values from the normal and extra precision parts of the code.\n        var lat = normalLat / PAIR_PRECISION_ + gridLat / FINAL_LAT_PRECISION_;\n        var lng = normalLng / PAIR_PRECISION_ + gridLng / FINAL_LNG_PRECISION_;\n        // Multiple values by 1e14, round and then divide. This reduces errors due\n        // to floating point precision.\n        return new CodeArea(\n            Math.round(lat * 1e14) / 1e14, Math.round(lng * 1e14) / 1e14,\n            Math.round((lat + latPrecision) * 1e14) / 1e14,\n            Math.round((lng + lngPrecision) * 1e14) / 1e14,\n            Math.min(code.length, MAX_DIGIT_COUNT_));\n    };\n\n    /**\n     * Recover the nearest matching code to a specified location.\n     *\n     * Given a valid short Open Location Code this recovers the nearest matching\n     * full code to the specified location.\n     *\n     * @param {string} shortCode A valid short code.\n     * @param {number} referenceLatitude The latitude to use for the reference\n     *     location.\n     * @param {number} referenceLongitude The longitude to use for the reference\n     *     location.\n     * @return {string} The nearest matching full code to the reference location.\n     * @throws {Exception} if the short code is not valid, or the reference\n     *     position values are not numbers.\n     */\n    OpenLocationCode.recoverNearest = function(\n        shortCode, referenceLatitude, referenceLongitude) {\n        if (!isShort(shortCode)) {\n            if (isFull(shortCode)) {\n                return shortCode.toUpperCase();\n            } else {\n                throw new Error(\n                    'ValueError: Passed short code is not valid: ' + shortCode);\n            }\n        }\n        referenceLatitude = Number(referenceLatitude);\n        referenceLongitude = Number(referenceLongitude);\n        if (isNaN(referenceLatitude) || isNaN(referenceLongitude)) {\n            throw new Error('ValueError: Reference position are not numbers');\n        }\n        // Ensure that latitude and longitude are valid.\n        referenceLatitude = clipLatitude(referenceLatitude);\n        referenceLongitude = normalizeLongitude(referenceLongitude);\n\n        // Clean up the passed code.\n        shortCode = shortCode.toUpperCase();\n        // Compute the number of digits we need to recover.\n        var paddingLength = SEPARATOR_POSITION_ - shortCode.indexOf(SEPARATOR_);\n        // The resolution (height and width) of the padded area in degrees.\n        var resolution = Math.pow(20, 2 - (paddingLength / 2));\n        // Distance from the center to an edge (in degrees).\n        var halfResolution = resolution / 2.0;\n\n        // Use the reference location to pad the supplied short code and decode it.\n        var codeArea = decode(\n            encode(referenceLatitude, referenceLongitude).substr(0, paddingLength)\n            + shortCode);\n        // How many degrees latitude is the code from the reference? If it is more\n        // than half the resolution, we need to move it north or south but keep it\n        // within -90 to 90 degrees.\n        if (referenceLatitude + halfResolution < codeArea.latitudeCenter &&\n            codeArea.latitudeCenter - resolution >= -LATITUDE_MAX_) {\n            // If the proposed code is more than half a cell north of the reference location,\n            // it's too far, and the best match will be one cell south.\n            codeArea.latitudeCenter -= resolution;\n        } else if (referenceLatitude - halfResolution > codeArea.latitudeCenter &&\n            codeArea.latitudeCenter + resolution <= LATITUDE_MAX_) {\n            // If the proposed code is more than half a cell south of the reference location,\n            // it's too far, and the best match will be one cell north.\n            codeArea.latitudeCenter += resolution;\n        }\n\n        // How many degrees longitude is the code from the reference?\n        if (referenceLongitude + halfResolution < codeArea.longitudeCenter) {\n            codeArea.longitudeCenter -= resolution;\n        } else if (referenceLongitude - halfResolution > codeArea.longitudeCenter) {\n            codeArea.longitudeCenter += resolution;\n        }\n\n        return encode(\n            codeArea.latitudeCenter, codeArea.longitudeCenter, codeArea.codeLength);\n    };\n\n    /**\n     * Remove characters from the start of an OLC code.\n     *\n     * This uses a reference location to determine how many initial characters\n     * can be removed from the OLC code. The number of characters that can be\n     * removed depends on the distance between the code center and the reference\n     * location.\n     *\n     * @param {string} code The full code to shorten.\n     * @param {number} latitude The latitude to use for the reference location.\n     * @param {number} longitude The longitude to use for the reference location.\n     * @return {string} The code, shortened as much as possible that it is still\n     *     the closest matching code to the reference location.\n     * @throws {Exception} if the passed code is not a valid full code or the\n     *     reference location values are not numbers.\n     */\n    OpenLocationCode.shorten = function(\n        code, latitude, longitude) {\n        if (!isFull(code)) {\n            throw new Error('ValueError: Passed code is not valid and full: ' + code);\n        }\n        if (code.indexOf(PADDING_CHARACTER_) != -1) {\n            throw new Error('ValueError: Cannot shorten padded codes: ' + code);\n        }\n        code = code.toUpperCase();\n        var codeArea = decode(code);\n        if (codeArea.codeLength < MIN_TRIMMABLE_CODE_LEN_) {\n            throw new Error(\n                'ValueError: Code length must be at least ' +\n                MIN_TRIMMABLE_CODE_LEN_);\n        }\n        // Ensure that latitude and longitude are valid.\n        latitude = Number(latitude);\n        longitude = Number(longitude);\n        if (isNaN(latitude) || isNaN(longitude)) {\n            throw new Error('ValueError: Reference position are not numbers');\n        }\n        latitude = clipLatitude(latitude);\n        longitude = normalizeLongitude(longitude);\n        // How close are the latitude and longitude to the code center.\n        var range = Math.max(\n            Math.abs(codeArea.latitudeCenter - latitude),\n            Math.abs(codeArea.longitudeCenter - longitude));\n        for (var i = PAIR_RESOLUTIONS_.length - 2; i >= 1; i--) {\n            // Check if we're close enough to shorten. The range must be less than 1/2\n            // the resolution to shorten at all, and we want to allow some safety, so\n            // use 0.3 instead of 0.5 as a multiplier.\n            if (range < (PAIR_RESOLUTIONS_[i] * 0.3)) {\n                // Trim it.\n                return code.substring((i + 1) * 2);\n            }\n        }\n        return code;\n    };\n\n    /**\n     * Clip a latitude into the range -90 to 90.\n     *\n     * @param {number} latitude\n     * @return {number} The latitude value clipped to be in the range.\n     */\n    var clipLatitude = function(latitude) {\n        return Math.min(90, Math.max(-90, latitude));\n    };\n\n    /**\n     * Compute the latitude precision value for a given code length.\n     * Lengths <= 10 have the same precision for latitude and longitude, but\n     * lengths > 10 have different precisions due to the grid method having\n     * fewer columns than rows.\n     * @param {number} codeLength\n     * @return {number} The latitude precision in degrees.\n     */\n    var computeLatitudePrecision = function(codeLength) {\n        if (codeLength <= 10) {\n            return Math.pow(ENCODING_BASE_, Math.floor(codeLength / -2 + 2));\n        }\n        return Math.pow(ENCODING_BASE_, -3) / Math.pow(GRID_ROWS_, codeLength - 10);\n    };\n\n    /**\n     * Normalize a longitude into the range -180 to 180, not including 180.\n     *\n     * @param {number} longitude\n     * @return {number} Normalized into the range -180 to 180.\n     */\n    var normalizeLongitude = function(longitude) {\n        while (longitude < -180) {\n            longitude = longitude + 360;\n        }\n        while (longitude >= 180) {\n            longitude = longitude - 360;\n        }\n        return longitude;\n    };\n\n    /**\n     * Coordinates of a decoded Open Location Code.\n     *\n     * The coordinates include the latitude and longitude of the lower left and\n     * upper right corners and the center of the bounding box for the area the\n     * code represents.\n     * @param {number} latitudeLo\n     * @param {number} longitudeLo\n     * @param {number} latitudeHi\n     * @param {number} longitudeHi\n     * @param {number} codeLength\n     *\n     * @constructor\n     */\n    var CodeArea = OpenLocationCode.CodeArea = function(\n        latitudeLo, longitudeLo, latitudeHi, longitudeHi, codeLength) {\n        return new OpenLocationCode.CodeArea.fn.Init(\n            latitudeLo, longitudeLo, latitudeHi, longitudeHi, codeLength);\n    };\n    CodeArea.fn = CodeArea.prototype = {\n        Init: function(\n            latitudeLo, longitudeLo, latitudeHi, longitudeHi, codeLength) {\n            /**\n             * The latitude of the SW corner.\n             * @type {number}\n             */\n            this.latitudeLo = latitudeLo;\n            /**\n             * The longitude of the SW corner in degrees.\n             * @type {number}\n             */\n            this.longitudeLo = longitudeLo;\n            /**\n             * The latitude of the NE corner in degrees.\n             * @type {number}\n             */\n            this.latitudeHi = latitudeHi;\n            /**\n             * The longitude of the NE corner in degrees.\n             * @type {number}\n             */\n            this.longitudeHi = longitudeHi;\n            /**\n             * The number of digits in the code.\n             * @type {number}\n             */\n            this.codeLength = codeLength;\n            /**\n             * The latitude of the center in degrees.\n             * @type {number}\n             */\n            this.latitudeCenter = Math.min(\n                latitudeLo + (latitudeHi - latitudeLo) / 2, LATITUDE_MAX_);\n            /**\n             * The longitude of the center in degrees.\n             * @type {number}\n             */\n            this.longitudeCenter = Math.min(\n                longitudeLo + (longitudeHi - longitudeLo) / 2, LONGITUDE_MAX_);\n        },\n    };\n    CodeArea.fn.Init.prototype = CodeArea.fn;\n\n    return OpenLocationCode;\n}));\n","/Users/yuriioleshko/orp-project/src/screen/MapBox.js",["124","125"],"/Users/yuriioleshko/orp-project/src/screen/PITable.js",[],{"ruleId":"126","replacedBy":"127"},{"ruleId":"128","replacedBy":"129"},{"ruleId":"126","replacedBy":"130"},{"ruleId":"128","replacedBy":"131"},{"ruleId":"126","replacedBy":"132"},{"ruleId":"128","replacedBy":"133"},{"ruleId":"126","replacedBy":"134"},{"ruleId":"128","replacedBy":"135"},{"ruleId":"136","severity":1,"message":"137","line":4,"column":8,"nodeType":"138","messageId":"139","endLine":4,"endColumn":11},{"ruleId":"136","severity":1,"message":"140","line":5,"column":8,"nodeType":"138","messageId":"139","endLine":5,"endColumn":14},{"ruleId":"126","replacedBy":"141"},{"ruleId":"128","replacedBy":"142"},{"ruleId":"143","severity":1,"message":"144","line":3,"column":23,"nodeType":"145","messageId":"146","endLine":3,"endColumn":29},{"ruleId":"147","severity":1,"message":"148","line":126,"column":38,"nodeType":"149","messageId":"150","endLine":126,"endColumn":40},{"ruleId":"147","severity":1,"message":"151","line":129,"column":38,"nodeType":"149","messageId":"150","endLine":129,"endColumn":40},{"ruleId":"147","severity":1,"message":"148","line":133,"column":25,"nodeType":"149","messageId":"150","endLine":133,"endColumn":27},{"ruleId":"147","severity":1,"message":"148","line":138,"column":42,"nodeType":"149","messageId":"150","endLine":138,"endColumn":44},{"ruleId":"147","severity":1,"message":"148","line":149,"column":50,"nodeType":"149","messageId":"150","endLine":149,"endColumn":52},{"ruleId":"147","severity":1,"message":"148","line":154,"column":63,"nodeType":"149","messageId":"150","endLine":154,"endColumn":65},{"ruleId":"147","severity":1,"message":"151","line":159,"column":46,"nodeType":"149","messageId":"150","endLine":159,"endColumn":48},{"ruleId":"147","severity":1,"message":"148","line":165,"column":56,"nodeType":"149","messageId":"150","endLine":165,"endColumn":58},{"ruleId":"147","severity":1,"message":"151","line":175,"column":27,"nodeType":"149","messageId":"150","endLine":175,"endColumn":29},{"ruleId":"147","severity":1,"message":"148","line":175,"column":78,"nodeType":"149","messageId":"150","endLine":175,"endColumn":80},{"ruleId":"147","severity":1,"message":"148","line":264,"column":63,"nodeType":"149","messageId":"150","endLine":264,"endColumn":65},{"ruleId":"147","severity":1,"message":"148","line":272,"column":22,"nodeType":"149","messageId":"150","endLine":272,"endColumn":24},{"ruleId":"143","severity":1,"message":"152","line":306,"column":18,"nodeType":"138","messageId":"153","endLine":306,"endColumn":19},{"ruleId":"143","severity":1,"message":"152","line":378,"column":22,"nodeType":"138","messageId":"153","endLine":378,"endColumn":23},{"ruleId":"147","severity":1,"message":"151","line":499,"column":46,"nodeType":"149","messageId":"150","endLine":499,"endColumn":48},{"ruleId":"136","severity":1,"message":"154","line":17,"column":7,"nodeType":"138","messageId":"139","endLine":17,"endColumn":16},{"ruleId":"136","severity":1,"message":"155","line":28,"column":12,"nodeType":"138","messageId":"139","endLine":28,"endColumn":22},"no-native-reassign",["156"],"no-negated-in-lhs",["157"],["156"],["157"],["156"],["157"],["156"],["157"],"no-unused-vars","'Map' is defined but never used.","Identifier","unusedVar","'MapBox' is defined but never used.",["156"],["157"],"no-redeclare","'module' is already defined as a built-in global variable.","Block","redeclaredAsBuiltin","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","Expected '!==' and instead saw '!='.","'i' is already defined.","redeclared","'stylesPol' is assigned a value but never used.","'createdMap' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]